---
title: "GSE114922 MDS Bulk Sequencing"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r packages}
library(tidyverse)
library(DESeq2)
library(rnaseqGene)
library(pheatmap)
library(ggalt)
library(fgsea)
library(biomaRt)
library(ggVennDiagram)
library(VennDiagram)
library(ggrepel)
library(jsonlite)
library(stringr)
library(fs)
library(dplyr)
library(GSVA)


setwd("C:/Users/rthalla/OneDrive - Loyola University Chicago/Zhang Lab/MDS Project/RNA Seq/GSE114922/")

EnsIDReplace2 <- function(input){
  gene_mapping <- read.csv("C:/Users/rthalla/OneDrive - Loyola University Chicago/Zhang Lab/Ensembl_labels_human.csv")
  rnanames <- rownames(input)
  id_list <- setNames(gene_mapping$gene_name, gene_mapping$gene_id)
  rnaname <- character(nrow(input))
  for (i in seq_len(nrow(input))) {
    ensembl_id <- rownames(input)[i]
    if (ensembl_id %in% names(id_list)) {
      rnaname[i] <- id_list[[ensembl_id]]
    } else{
      rnaname[i] <- ensembl_id
    }
  }
  rnaname[rnaname == ""] <- NA
  
  rownames(input) <- make.names(rnaname, unique = TRUE)
  rm(gene_mapping, id_list, ensembl_id, i, rnaname)
}

run_gsea <- function(dds, condition1, condition2, gmt_path, output_gsea, output_deg) {
  res1 <- DESeq2::results(dds, 
                       contrast = c("Mutation", condition1, condition2),
                       independentFiltering = TRUE,
                       alpha = 0.1,
                       parallel = FALSE)
rnk <- setNames(res1$log2FoldChange, rownames(res1))
rnk <- rnk[!is.na(rnk)]
gmt <- gmtPathways(gmt_path)
gsea <- fgsea(pathways = gmt, stats = rnk, minSize = 15, maxSize = 500)
gseadf <- as.data.frame(gsea)
list_columns <- sapply(gseadf, is.list)
gseadf[list_columns] <- lapply(gseadf[list_columns], function(col) sapply(col, paste, collapse = ";"))
write.csv(gseadf, output_gsea)
res1_filtered <- res1[complete.cases(res1), ]
write.csv(res1_filtered, output_deg)
}
```

```{r functions}
run_gsea <- function(dds, condition1, condition2, gmt_path, output_gsea, output_deg) {
  suppressPackageStartupMessages({
    library(DESeq2)
    library(fgsea)
    library(BiocParallel)
    library(dplyr)
  })

  # Force serial execution to avoid BiocParallel crashes
  BiocParallel::register(BiocParallel::SerialParam())

  #-------------------------------
  # 1. Validate contrast levels
  #-------------------------------
  if (!"Mutation" %in% colnames(colData(dds))) {
    stop("Column 'Mutation' not found in colData(dds).")
  }

  mut_levels <- levels(dds$Mutation)

  if (!(condition1 %in% mut_levels)) {
    stop(paste("Condition1 not found in Mutation levels:", condition1))
  }
  if (!(condition2 %in% mut_levels)) {
    stop(paste("Condition2 not found in Mutation levels:", condition2))
  }

  #-------------------------------
  # 2. Run DESeq2 contrast
  #-------------------------------
  res <- DESeq2::results(
    dds,
    contrast = c("Mutation", condition1, condition2),
    independentFiltering = TRUE,
    alpha = 0.1,
    parallel = FALSE
  )

  # Remove rows with NA statistics
  res <- res[complete.cases(res$stat), ]

  #-------------------------------
  # 3. Build ranking vector
  #-------------------------------
  rnk <- setNames(res$stat, rownames(res))

  if (length(rnk) < 1000) {
    stop("Ranking vector too small (<1000 genes). Likely no signal in this contrast.")
  }

  #-------------------------------
  # 4. Load pathways
  #-------------------------------
  gmt <- fgsea::gmtPathways(gmt_path)

  #-------------------------------
  # 5. Run fgsea
  #-------------------------------
  gsea <- fgsea(
    pathways = gmt,
    stats = rnk,
    minSize = 15,
    maxSize = 500
  )

  gsea_df <- as.data.frame(gsea)

  # Flatten list columns (leadingEdge)
  list_cols <- sapply(gsea_df, is.list)
  gsea_df[list_cols] <- lapply(gsea_df[list_cols], function(x) sapply(x, paste, collapse = ";"))

  #-------------------------------
  # 6. Write outputs
  #-------------------------------
  write.csv(gsea_df, output_gsea, row.names = FALSE)

  # DEG table (filtered for significance)
  deg_df <- as.data.frame(res) %>%
    mutate(gene = rownames(res)) %>%
    filter(padj < 0.1)

  write.csv(deg_df, output_deg, row.names = FALSE)

  #-------------------------------
  # 7. Return objects invisibly
  #-------------------------------
  invisible(list(
    gsea = gsea_df,
    degs = deg_df,
    ranking = rnk
  ))
}

EnsIDReplace2 <- function(input, mapping_file = "C:/Users/rthalla/OneDrive - Loyola University Chicago/Zhang Lab/Ensembl_labels_human.csv") {
  #-----------------------------
  # 1. Validate inputs
  #-----------------------------
  if (!is.matrix(input) && !is.data.frame(input)) {
    stop("Input must be a matrix or data.frame with rownames.")
  }
  if (is.null(rownames(input))) {
    stop("Input must have rownames corresponding to Ensembl IDs.")
  }
  if (!file.exists(mapping_file)) {
    stop(paste("Mapping file not found:", mapping_file))
  }

  #-----------------------------
  # 2. Load mapping file
  #-----------------------------
  gene_mapping <- read.csv(mapping_file, stringsAsFactors = FALSE)

  required_cols <- c("gene_id", "gene_name")
  if (!all(required_cols %in% colnames(gene_mapping))) {
    stop("Mapping file must contain columns: gene_id, gene_name")
  }

  #-----------------------------
  # 3. Build lookup vector
  #-----------------------------
  id_list <- setNames(gene_mapping$gene_name, gene_mapping$gene_id)

  #-----------------------------
  # 4. Vectorized name replacement
  #-----------------------------
  old_ids <- rownames(input)

  # Replace Ensembl IDs with gene names where available
  new_names <- id_list[old_ids]

  # For IDs not found in mapping, keep original
  new_names[is.na(new_names)] <- old_ids[is.na(new_names)]

  # Replace empty strings with NA
  new_names[new_names == ""] <- NA

  # Ensure syntactically valid + unique names
  new_names <- make.names(new_names, unique = TRUE)

  #-----------------------------
  # 5. Apply new rownames
  #-----------------------------
  rownames(input) <- new_names

  #-----------------------------
  # 6. Return modified object
  #-----------------------------
  return(input)
}


```

```{r gene names}
cts <- read.table("GSE114922_Count_table.txt", row.names = 1)
samples <- colnames(cts)
samples <- sub("^PEL2031", "", samples)
colnames(cts) <- samples

cts <- EnsIDReplace2(cts)

write.csv(cts, "genenamecounts.csv")  
```

```{r load data}
cts <- read.csv("genenamecounts.csv", row.names = 1)
cd <- read.csv("totalcoldata.csv")
dds <- DESeqDataSetFromMatrix(countData = cts, colData = cd, design = ~Mutation)
```

```{r single gene expression}
dds <- estimateSizeFactors(dds)
norm <- counts(dds, normalized = TRUE) 
tbk1_vec <- norm["TBK1", ]

df <- data.frame( sample = names(tbk1_vec), tbk1 = as.numeric(tbk1_vec) ) 
df_ordered <- df %>% arrange(tbk1)

# Extract Mutation column
mutation_df <- as.data.frame(colData(dds)) %>%
  dplyr::select(Mutation) %>%
  tibble::rownames_to_column("sample")

# Merge with your ordered TBK1 dataframe
df_ordered2 <- df_ordered %>%
  left_join(mutation_df, by = "sample")


tbk1plot <- ggplot(df_ordered2, aes(x = reorder(sample, tbk1), y = tbk1, fill = Mutation)) + 
  geom_col() + 
  labs(title = "TBK1 Expression in MDS", x = "Sample", y = "TBK1 Expression (normalized counts)") + 
  theme_bw() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
tbk1plot

ggsave("tbk1_patientsamples.png", tbk1plot, dpi = 600)

```

```{r dds}
dds <- DESeq(dds)
vst <- vst(dds, blind=FALSE)
rescmp <- results(dds)
```

```{r pca}
pca <- plotPCA(vst, intgroup = "Mutation")
allpca <- pca + geom_point(size=5) + 
  theme(
    panel.background = element_rect(fill = "white", color = "black"), # White background
    axis.text = element_blank(),
    axis.ticks = element_blank(),
  )
allpca

ggsave("pca.png", allpca, dpi = 600)
```

```{r gsea}
run_gsea(dds, "SF3B1", "Healthy", "humangseapathways.gmt", "sf3b1gsea.csv", "sf3b1deg.csv")

run_gsea(dds, "SF3B1", "Other", "humangseapathways.gmt", "sf3b1mdsgsea.csv", "sf3b1mdsdeg.csv")
```

```{r broad correlations}
sf3b1_samples <- rownames(colData(dds))[colData(dds)$Mutation == "SF3B1"]
dds_sf3b1 <- dds[, sf3b1_samples]
dds_sf3b1 <- estimateSizeFactors(dds_sf3b1)
norm <- counts(dds_sf3b1, normalized = TRUE) 
tbk1_vec <- norm["TBK1", ]

# Use apply over rows, return a list of results
cor_list <- apply(norm, 1, function(gene_expr) {
  test <- cor.test(gene_expr, tbk1_vec,
                   method = "spearman",
                   use = "pairwise.complete.obs")
  data.frame(cor = test$estimate,
             pval = test$p.value)
})

# Bind results into a single data frame
cor_df <- do.call(rbind, cor_list)

# Add gene names
cor_df$gene <- rownames(norm)

# Reorder columns
cor_df <- cor_df[, c("gene", "cor", "pval")]

head(cor_df, 20)

write.csv(cor_df, "tbk1_correlation.csv")

rnk <- cor_df$cor
names(rnk) <- rownames(cor_df)
rnk <- rnk[!is.na(rnk)]

gmt <- gmtPathways("humangseapathways.gmt")
gsea <- fgsea(pathways = gmt, stats = rnk, minSize = 15, maxSize = 500)
gseadf <- as.data.frame(gsea)
list_columns <- sapply(gseadf, is.list)
gseadf[list_columns] <- lapply(gseadf[list_columns], function(col) sapply(col, paste, collapse = ";"))
write.csv(gseadf, "tbk1_gsea_cor.csv")
gseadf_subset <- subset(gseadf, padj < 0.25)
write.csv(gseadf_subset, "tbk1corgseafiltered.csv")

```